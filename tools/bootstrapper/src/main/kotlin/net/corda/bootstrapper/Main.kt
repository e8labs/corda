package net.corda.bootstrapper

import net.corda.cliutils.CordaCliWrapper
import net.corda.cliutils.start
import net.corda.core.internal.PLATFORM_VERSION
import net.corda.core.node.JavaPackageName
import net.corda.nodeapi.internal.crypto.loadKeyStore
import net.corda.nodeapi.internal.network.NetworkBootstrapper
import picocli.CommandLine
import picocli.CommandLine.Option
import java.nio.file.Path
import java.nio.file.Paths
import java.security.PublicKey

fun main(args: Array<String>) {
    NetworkBootstrapperRunner().start(args)
}

class NetworkBootstrapperRunner : CordaCliWrapper("bootstrapper", "Bootstrap a local test Corda network using a set of node configuration files and CorDapp JARs") {
    @Option(
            names = ["--dir"],
            description = [
                "Root directory containing the node configuration files and CorDapp JARs that will form the test network.",
                "It may also contain existing node directories."
            ]
    )
    private var dir: Path = Paths.get(".")

    @Option(names = ["--no-copy"], description = ["""Don't copy the CorDapp JARs into the nodes' "cordapps" directories."""])
    private var noCopy: Boolean = false

    @Option(names = ["--minimum-platform-version"], description = ["The minimumPlatformVersion to use in the network-parameters."])
    private var minimumPlatformVersion = PLATFORM_VERSION

    @Option(names = ["--register-package-owner"],
            converter = [JavaPackageNameConverter::class, PublicKeyConverter::class],
            description = [
                "Register owner of java package namespace in the network-parameters.",
                "Format: [java-package-namespace=keystore-file:password:alias]",
                "         `java-package-namespace` is case insensitive and cannot be a sub-package of an existing registered namespace",
                "         `keystore-file` refers to the location of key store file containing the signed certificate as generated by the Java 'keytool' tool (see https://docs.oracle.com/javase/8/docs/technotes/tools/windows/keytool.html)",
                "         `password` to open the key store",
                "         `alias` refers to the name associated with a certificate containing the public key to be associated with the package namespace"
            ])
    var registerPackageOwnership: Map<JavaPackageName, PublicKey> = mutableMapOf()

    @Option(names = ["--unregister-package-owner"],
            converter = [JavaPackageNameConverter::class],
            description = [
                "Unregister owner of java package namespace in the network-parameters.",
                "Format: [java-package-namespace]",
                "         `java-package-namespace` is case insensitive and cannot be a sub-package of an existing registered namespace"
            ])
    var javaPackageName: List<JavaPackageName> = mutableListOf()

    override fun runProgram(): Int {
        NetworkBootstrapper().bootstrap(dir.toAbsolutePath().normalize(),
                copyCordapps = !noCopy,
                minimumPlatformVersion = minimumPlatformVersion,
                packageOwnership = registerPackageOwnership.plus(javaPackageName.map { Pair(it, null) })
        )
        return 0 //exit code
    }
}

/**
 * Converter from String to JavaPackageName.
 */
class JavaPackageNameConverter : CommandLine.ITypeConverter<JavaPackageName> {
    override fun convert(packageName: String): JavaPackageName {
        return JavaPackageName(packageName)
    }
}

/**
 * Converter to extract PublicKey from KeyStore specification (keyStorePath:password:alias)
 */
class PublicKeyConverter : CommandLine.ITypeConverter<PublicKey> {
    override fun convert(keyStore: String): PublicKey {
        if (!keyStore.isBlank()) {
            val keyStoreSpec = keyStore.split(":")
            if (keyStoreSpec.size != 3)
                throw IllegalArgumentException("keystore argument must specify 3 elements separated by semi-colon: 'keyStorePath:password:alias'")
            val ks = loadKeyStore(Paths.get(keyStoreSpec[0]), keyStoreSpec[1])
            return ks.getCertificate(keyStoreSpec[2]).publicKey
        }
        else throw IllegalArgumentException("Must specify keystore argument: 'keyStorePath:password:alias'")
    }
}
